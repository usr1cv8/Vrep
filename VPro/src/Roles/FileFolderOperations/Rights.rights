<?xml version="1.0" encoding="UTF-8"?>
<Rights xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://v8.1c.ru/8.2/roles" xsi:type="Rights">
	<setForNewObjects>false</setForNewObjects>
	<setForAttributesByDefault>true</setForAttributesByDefault>
	<independentRightsOfChildObjects>false</independentRightsOfChildObjects>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.TabularSection.Commands.Attribute.ShowAlert</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.FilesInWorkingDirectory.Resource.ForRead</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalAttributesAndInformationSets.TabularSection.AdditionalInformation.Attribute.Property</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserSettingsOfAccessToDataProcessors.Dimension.User</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackupSetup.Attribute.BackupScheduleOption</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.TabularSection.Users</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.DataSuccessfullyImported</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.ReceiverPictureIndex</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ObjectsPropertiesValues.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ObjectsPropertiesValues.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ObjectsPropertiesValues.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ObjectsPropertiesValues.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ObjectsPropertiesValues.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ObjectsPropertiesValues.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ObjectsPropertiesValues.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ObjectsPropertiesValues.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.WorkingFileDirectories.Dimension.Folder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.TabularSection.Commands</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.UnmappedObjectsCount</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UserWorkBlocking.Attribute.MessageForUsers</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.SortTable.Attribute.FieldName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AttachedFilesExist.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AttachedFilesExist.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AttachedFilesExist.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AttachedFilesExist.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.Attribute.DeleteObjectKey</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.VersionStoredFiles</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#ByValuesAndSetsAdvanced("InformationRegister.VersionStoredFiles", "", "",
"",
"",
"Object","T.FileVersion.Owner.FileOwner","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.TabularSection.Placement.Attribute.DeleteName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfUnapprovedLinks.Attribute.UniqueReceiverHandle</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalAttributesAndInformationSets.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalAttributesAndInformationSets.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalAttributesAndInformationSets.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalAttributesAndInformationSets.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalAttributesAndInformationSets.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalAttributesAndInformationSets.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalAttributesAndInformationSets.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalAttributesAndInformationSets.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ObjectsVersions.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ObjectsVersions.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ObjectsVersions.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ObjectsVersions.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.FILECompressOutgoingMessageFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.Password</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.SourceInfobasePrefix</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ChangeProhibitionDates.Attribute.ProhibitionDateDescription</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ScannedFileNumbers.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ScannedFileNumbers.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ScannedFileNumbers.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ScannedFileNumbers.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.SMTPAuthenticationMode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.ChangingProhibitionDatesSections.StandardAttribute.ValueType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.ChangingProhibitionDatesSections.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.ChangingProhibitionDatesSections.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.ChangingProhibitionDatesSections.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.ChangingProhibitionDatesSections.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.ChangingProhibitionDatesSections.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.ChangingProhibitionDatesSections.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.ChangingProhibitionDatesSections.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.Attribute.ScheduledJobGUID</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.EMAILAccount</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ContactInformationKinds.Attribute.DomesticAddressOnly</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.Resource.XML_Rules</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ObjectsVersions.Dimension.Object</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.GroupAttributeChange.Attribute.UsedAdditInfo</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.FilesInWorkingDirectory.Resource.Path</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.AdditionalAttributesAndInformation.StandardAttribute.ValueType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.AdditionalAttributesAndInformation.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.AdditionalAttributesAndInformation.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.AdditionalAttributesAndInformation.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.AdditionalAttributesAndInformation.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.AdditionalAttributesAndInformation.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.AdditionalAttributesAndInformation.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.AdditionalAttributesAndInformation.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.FTPConnectionPort</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.GroupAttributeChange.Attribute.AbortOnError</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ExchangeMessagesTransportFILE.Attribute.FILECompressOutgoingMessageFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.TabularSection.Placement.Attribute.DeleteFixed</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.Attribute.Prefix</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserPrintTemplates.Dimension.Object</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.SuccessfulDataExchangeStatus.Resource.EndDate</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.Attribute.Comment</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.TabularSection.Commands.Attribute.Modifier</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.SMTPPassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.TableFields</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ImportDataInExchangeMode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ExchangeMessagesTransportFILE.Attribute.MessageFileTemplateName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.EmailExchangeMessagesTransport.Attribute.EMAILAccount</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ImportObjectsByRefWithoutDeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ChangeProhibitionDates.Resource.ProhibitionDate</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfUnapprovedLinks.Attribute.UniqueSourceHandle</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CalendarSchedules.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CalendarSchedules.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CalendarSchedules.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CalendarSchedules.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CalendarSchedules.Resource.NumberOfDaysInScheduleSinceTheBeginningOfTheYear</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.TabularSection.ContactInformation.Attribute.Country</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.AdditionalAttributesAndInformation.Attribute.ThisIsAdditionalInformation</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalAttributesAndInformationSets.TabularSection.AdditionalInformation</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.TabularSection.Commands.Attribute.ScheduledJobGUID</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.SecondInfobaseNewNodeCode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.ReceiverField3</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Calendars.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Calendars.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Calendars.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Calendars.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Calendars.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Calendars.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Calendars.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Calendars.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.ExchangePlanName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.Attribute.ListOfUsedFields</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.Attribute.ReceiverTableName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>CommonCommand.SetRights</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.WorldCountries.Attribute.AlphaCode2</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ShowRequestWhileDataImportInDataProcessorOpening</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.TabularSection.AccessKinds.Attribute.AccessKind</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesObjectsCompliance.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesObjectsCompliance.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesObjectsCompliance.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesObjectsCompliance.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.Data</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.TemporaryFileNameOfExchangeProtocol</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteRightsByAccessValues.Dimension.AccessValue</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.Attribute.Responsible</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.TypeOfChangesRegistrationDeletionForExchangeNodesAfterDump</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Currencies.Attribute.ExportingFromInternet</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.UsersGroups.Attribute.Comment</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.Attribute.VariantKey</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesObjectsCompliance.Dimension.UniqueSourceHandle</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.EndDate</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfUnapprovedLinks.Attribute.ReceiverType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ContactInformationKinds.Attribute.Type</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackup.Attribute.BackupDirectory</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.AdditionalAttributesAndInformation.Attribute.ToolTip</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.InfobaseForConnectionUser</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.TabularSection.Placement.Attribute.DeleteSubsystem</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.TabularSection.Purpose.Attribute.DeleteMetadataObjectFullName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.Attribute.ExchangeMessageFileName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.SourcePictureIndex</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ErrorFlag</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ExchangeProtocolFileNameImporting</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.TabularSection.AccessValues.Attribute.AccessValue</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.TabularSection.ContactInformation.Attribute.Country</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.ReceiverField1</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackupSetup.Attribute.CreateBackupWhenDataRestoring</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.CountProcessedObjectsForRefreshStatus</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UsersGroupsContents.Dimension.User</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.UpdateSource</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.FILEInformationExchangeDirectory</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.TabularSection.ExchangeSettings</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.UseForSending</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.Version2Digit</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.UpdateResult</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileVersions.Command.OpenFileVersions</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.TabularSection.ExchangeSettings.Attribute.RunningAction</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.ObjectsCountInSource</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.TabularSection.AccessKinds.Attribute.AccessKind</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.TabularSection.Commands.Attribute.ID</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackup.Attribute.ExecuteBackingUpNow</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.Resource.RulesTemplateName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.OpenExchangeProtocolAfterOperationsComplete</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.FTPCompressOutgoingMessageFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesObjectsCompliance.Dimension.UniqueReceiverHandle</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.UpdateServerUserCode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.ReceiverField5</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.OneToMany</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AttachedFilesExist.Resource.HasFiles</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.SourceType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.TabularSection.AccessKinds</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.Resource.ExchangePlanNameFromRules</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformation.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformation.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformation.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformation.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.TabularSection.ContactInformation.Attribute.FieldValues</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.ReceiverField2</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.ExchangeMessageTransportKind</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.PathToDigitalSignaturesAndEncryptionApplicationsOnLinuxServers.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.PathToDigitalSignaturesAndEncryptionApplicationsOnLinuxServers.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.PathToDigitalSignaturesAndEncryptionApplicationsOnLinuxServers.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.PathToDigitalSignaturesAndEncryptionApplicationsOnLinuxServers.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.Attribute.Comment</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.InfobaseForConnectionServerName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.UpdateFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeStatus.Dimension.ActionOnExchange</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.FILECompressOutgoingMessageFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.Resource.RulesSource</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.TabularSection.AccessKinds</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.SchedulerTaskCode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.TabularSection.Placement</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.WorkingFileDirectories.Resource.Path</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.Resource.RulesFilename</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.AdditionalAttributesAndInformation.Attribute.FormatProperties</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.SMTPAuthentication</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.FilesInWorkingDirectory.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.FilesInWorkingDirectory.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.FilesInWorkingDirectory.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.FilesInWorkingDirectory.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.InfobaseForConnectionDirectory</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.LeaveMessageCopiesOnServer</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ExchangeMode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ErrorMessagesOutputToLog</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsers.Attribute.InfobaseUserID</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.Attribute.SafeMode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AttachedFiles.Resource.StoredFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteRightsByAccessValues.Resource.SpreadInHierarchy</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CalendarSchedules.Dimension.Year</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ContactInformationKinds.Attribute.EditInDialogOnly</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.DumpConfigurationProcedures</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeStatus.Resource.ExchangeProcessResult</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UserWorkBlocking.Attribute.LockEnding</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ObjectsVersions.Dimension.VersionNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.EmailExchangeMessagesTransport.Attribute.MessageFileTemplateName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.AssistantOperationOption</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.ITSDiskNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteRightsByAccessValues.Dimension.Table</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.FileNameOfEventHandlers</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ItemsCountInTransactionOnExportForExchangePlans</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.ExchangeMessageTransportKindByDefault</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ExchangeMessagesTransportFILE.Attribute.ExchangeMessageArchivePassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.EmailExchangeMessagesTransport.Attribute.EMAILCompressOutgoingMessageFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.InfobaseConnectionWindowsAuthentication</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.SourceField5</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.UnloadRulesTable</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.Attribute.Definition</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.SourceTypeAsString</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.InfobaseTypeForConnection</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.Attribute.Profile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ExchangeMessagesTransportFTP.Attribute.FTPConnectionUser</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.SearchFields</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteObjectVersioningSettings.Dimension.ObjectType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ExchangeMessagesTransportFTP.Attribute.MessageFileTemplateName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesNodesCommonSettings.Dimension.InfobaseNode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.ThisIsSettingOfDistributedInformationBase</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Files.Command.LockedFiles</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.Attribute.Version</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.DontOutputNoInformationMessagesToUser</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.TabularSection.ContactInformation.Attribute.PhoneNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>CommonForm.ObjectRightsSettings</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.EMAILMaximumValidMessageSize</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AttachedFiles.Dimension.AttachedFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeStatus.Dimension.InfobaseNode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ExchangeMessagesTransportFTP.Attribute.FTPConnectionMaximumValidMessageSize</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ExchangeMessagesTransportFTP.Attribute.FTPConnectionPassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.SortTable.Attribute.Use</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.DeleteResponsibleForEmailProcessing</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.TabularSection.Users.Attribute.User</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.UseTransportParametersFILE</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformationProcessorsFunctions.Resource.UseObjectFill</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.TabularSection.ContactInformation.Attribute.Type</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ObjectsVersions.Attribute.VersionAuthor</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ObjectsCountForTransactions</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.Attribute.VisibleByDefault</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.UseTransportParametersEMAIL</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.InfoMessagesOutputToMessagesWindow</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.EMAILCompressOutgoingMessageFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Files.Command.FileFolders</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.SourceField2</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.SavedSettings</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.TabularSection.Roles</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.UpdateDateTime</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.DataExchangeSettingsForImportFileName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeStatus.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeStatus.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeStatus.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeStatus.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.Attribute.User</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserSettingsOfAccessToDataProcessors.Dimension.AdditionalReportOrDataProcessor</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.EventHandlersExternalDataProcessorFileName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteObjectVersioningSettings.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteObjectVersioningSettings.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteObjectVersioningSettings.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteObjectVersioningSettings.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.Attribute.Type</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.Attribute.UseScheduledJob</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserPrintTemplates.Attribute.Use</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ExchangeMessagesTransportFTP.Attribute.ExchangeMessageArchivePassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.Attribute.Responsible</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.FTPConnectionMaximumValidMessageSize</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackupSetup.Attribute.CopiesCount</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.TabularSection.ContactInformation.Attribute.EmailAddress</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformationProcessorsFunctions.Resource.UsePrintForms</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.TabularSection.ExchangeSettings.Attribute.InfobaseNode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.Resource.ReadOutRules</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.DoNotAskQuestionOnDataImportOnDataProcessorOpen</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.TabularSection.AccessValues.Attribute.AccessKind</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.TabularSection.ContactInformation.Attribute.EmailAddress</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.UsersGroups.TabularSection.Content</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.Attribute.UseForObjectForm</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.OutgoingMailServerPort</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackup.Attribute.BackingUpTypeCode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.FTPConnectionMaximumValidMessageSize</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.WriteRegistersViaRecordSets</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesObjectsCompliance.Attribute.ObjectExportedByRef</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformationProcessorsFunctions.Dimension.ObjectTypeDelete</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.TabularSection.ContactInformation.Attribute.PhoneNumberWithoutCodes</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.FTPConnectionPassiveConnection</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.Dimension.ExchangePlanName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.FTPConnectionPort</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackup.Attribute.CreateBackupWhenDataRestoring</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.Attribute.ExchangeMessageTransportKind</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.Attribute.ReportType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.SynchronizeByID</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserSettingsOfAccessToDataProcessors.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserSettingsOfAccessToDataProcessors.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserSettingsOfAccessToDataProcessors.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserSettingsOfAccessToDataProcessors.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.TabularSection.AccessKinds.Attribute.AllAllowed</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.Resource.RulesInformation</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CalendarSchedules.Resource.DayIncludedInSchedule</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteObjectVersioningSettings.Resource.Variant</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.UpdateMode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ImportConfigurationProcedures</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.IncomingMailServer</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.EMAILMaximumValidMessageSize</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.TabularSection.AccessValues</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.ReceiverType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Currencies.Attribute.InWordParametersInEnglish</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformationProcessorsFunctions.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformationProcessorsFunctions.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformationProcessorsFunctions.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformationProcessorsFunctions.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ContactInformationKinds.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ContactInformationKinds.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ContactInformationKinds.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ContactInformationKinds.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ContactInformationKinds.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ContactInformationKinds.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ContactInformationKinds.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ContactInformationKinds.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.Attribute.TemporaryExchangeMessagesDirectoryName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.FILEInformationExchangeDirectory</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeStatus.Resource.StartDate</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.DataExchangeSettingsFileName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformation.Dimension.Property</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.TabularSection.ContactInformation.Attribute.PhoneNumberWithoutCodes</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ParametersSettingsTable</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ScannedFileNumbers.Resource.Number</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfUnapprovedLinks</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.CommentDuringDataExport</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.TabularSection.Purpose</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.FilesInWorkingDirectory.Resource.PlacementDateIntoWorkingDirectory</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.Attribute.ReceiverTypeAsString</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesObjectsCompliance.Resource.UniqueSourceHandleAsString</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.FlushRulesTable</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.GroupAttributeChange.Attribute.ChangeInTransaction</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.InfobaseForConnectionPlatformVersion</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackupSetup.Attribute.BackupDirectory</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.Attribute.ThisIsObjectDeletion</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.TabularSection.AccessKinds.Attribute.AllAllowed</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.TabularSection.ContactInformation.Attribute.Presentation</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.ObjectsCountInReceiver</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ArchiveFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.SMTPUser</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ExchangeMessagesTransportFTP.Attribute.FTPConnectionPath</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.PathToDigitalSignaturesAndEncryptionApplicationsOnLinuxServers.Dimension.ComputerName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.Attribute.InfobaseNode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UserWorkBlocking.Attribute.UnlockCode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ExportAllowedOnly</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ObjectsVersions.Attribute.VersionDate</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.AdditionalAttributesAndInformation.Attribute.MultilineTextBox</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ExchangeMessagesTransportFTP.Attribute.FTPCompressOutgoingMessageFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileFolders.TabularSection.AdditionalAttributes.Attribute.TextString</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.PathToDigitalSignaturesAndEncryptionApplicationsOnLinuxServers.Resource.PathToApplication</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.Attribute.Author</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DistributedInfobaseObjectsConversion.Attribute.InfobaseNode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.ReceiverTableName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.TabularSection.DeleteQuickAccessExceptions.Attribute.DeleteUser</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.UseScheduleForUpdateCheck</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.SaveUpdatesServerPassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformationProcessorsFunctions.Resource.UseCreatingLinkedObjects</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.GroupAttributeChange.Attribute.UsedAdditAttributes</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UsersGroupsContents.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UsersGroupsContents.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UsersGroupsContents.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UsersGroupsContents.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.TabularSection.Sections</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.UsePreview</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Currencies.Attribute.Markup</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserPrintTemplates.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserPrintTemplates.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserPrintTemplates.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserPrintTemplates.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserSettingsOfAccessToDataProcessors.Resource.Available</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.KeepAdditionalWriteControlToXML</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.UseForReceiving</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.RestoreInfobase</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ExchangeRulesVersion</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.PathToLocalUpdateFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeStatus.Resource.EndDate</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.AdditionalAttributesAndInformation.Attribute.Comment</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.TabularSection.Sections.Attribute.DeleteSectionName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.NumberOfObjectsMapped</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.Key</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.TabularSection.DeleteQuickAccessExceptions</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ExchangeMessagesTransportFILE.Attribute.FILEInformationExchangeDirectory</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes.Attribute.MaximumSize</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.Comment</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.CutRowsFromRight</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.UseTransactions</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ChangeProhibitionDates.Dimension.Object</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes.Attribute.FullPathLinux</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsers.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsers.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsers.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsers.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsers.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsers.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsers.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsers.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.Timeout</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileFolders</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#ByValues("Catalog.FileFolders", "", "",
"RightSettings", "Ref", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","")</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#ByValues("Catalog.FileFolders", "", "",
"RightSettings", "Ref", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","")</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#ByValues("Catalog.FileFolders", "", "",
"RightSettings", "Ref", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","", "","")</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.ExchangeMessageArchivePassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.InfobaseBackupDirectoryName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.ObjectTypeAsString</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackup.Attribute.BackupScheduleOption</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.UseFilterByDateForAllObjects</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.FilesInWorkingDirectory.Resource.InOwnerWorkingDirectory</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.EmailAddress</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.FilesInWorkingDirectory.Dimension.Version</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ContactInformationKinds.Attribute.AdditionalOrderingAttribute</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.WorkingFileDirectories.Dimension.User</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.WriteToInformationBaseChangedObjectsOnly</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AttachedFilesExist.Attribute.ObjectID</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.FTPCompressOutgoingMessageFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.Attribute.InfobaseNode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.HandlersDebugModeFlag</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.Attribute.InfobaseUserID</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.Attribute.ReceiverTableFields</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ChangeProhibitionDates.Attribute.Comment</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ExchangeRulesFilename</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.UpdateFileName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.FTPConnectionUser</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesNodesCommonSettings.Attribute.SentNo</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.SuccessfulDataExchangeStatus.Dimension.ActionOnExchange</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserSettingsOfAccessToDataProcessors.Dimension.CommandID</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.ObjectsMappingPercent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.TabularSection.ContactInformation.Attribute.FieldValues</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.TabularSection.AccessValues</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.TabularSection.ContactInformation.Attribute.State</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.Attribute.UseSelectiveObjectsRegistrationFilter</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.UsersGroups.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.UsersGroups.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.UsersGroups.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.UsersGroups.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.UsersGroups.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.UsersGroups.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.UsersGroups.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.UsersGroups.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.ReceiverField4</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.Dimension.RuleKind</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>CommonForm.MainWorkingDirectorySetting</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.DeleteIncludeUserNameInPresentation</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.StartDate</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.InfobaseForConnectionPassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.UpdateFileSize</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteRightsByAccessValues.Dimension.User</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesObjectsCompliance.Dimension.InfobaseNode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesNodesCommonSettings.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesNodesCommonSettings.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesNodesCommonSettings.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesNodesCommonSettings.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.ScheduleOfUpdateExistsCheck</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.Attribute.ExchangePlanName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CurrencyRates.Resource.ExchangeRate</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.DataExportDate</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackupSetup.Attribute.RestrictionType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.SourceField1</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfUnapprovedLinks.Attribute.SourceType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.TabularSection.ContactInformation.Attribute.Kind</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.EmailExchangeMessagesTransport.Attribute.EMAILMaximumValidMessageSize</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformation.Resource.Value</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.DirectReadInRecipientInfobase</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UserWorkBlocking.Attribute.LockBegin</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.VersionForUpdate</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackup.Attribute.AdministratorPassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ObjectsPropertiesValues.Attribute.Weight</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.Attribute.FileName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Dimension.Node</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ThisIsInteractiveMode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackupSetup.Attribute.PeriodMeasurementUnit</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.Attribute.TypeOfAuthorizationObjects</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesObjectsCompliance.Dimension.ReceiverType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.Version4Digit</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes.Attribute.Comment</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackupSetup.Attribute.ValueInMeasurementUnits</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.SecondStart</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.InfobaseNameOnServerForConnection</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackup.Attribute.BackupImportingFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.ExchangeMessageArchivePassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalAttributesAndInformationSets.TabularSection.AdditionalAttributes</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.IncomingMailServerPort</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.AlgorithmsDebugMode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ExchangeFileExtractionPassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.EMAILCompressOutgoingMessageFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.Attribute.Comment</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.TabularSection.ContactInformation.Attribute.Presentation</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.ServerEmailStoragePeriod</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>CommonCommand.AttachedFiles</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.LocalRelativeDirectory</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.UseTransactionsOnExportForExchangePlans</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.TechnicalErrorInfo</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.TabularSection.ContactInformation.Attribute.Kind</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.TabularSection.Content</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserPrintTemplates.Resource.Template</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.Version1Digit</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.TabularSection.ContactInformation.Attribute.PhoneNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsers.Attribute.DeletePassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.EMAILAccount</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.Attribute.DataProcessorStorage</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ObjectRegistrationRulesImport.Attribute.ExchangePlanImportName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalAttributesAndInformationSets.TabularSection.AdditionalAttributes.Attribute.Property</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.FTPConnectionPassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.Attribute.Publication</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformationProcessorsFunctions.Dimension.FormType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.AppendDataToExchangeProtocol</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.UpdatesServerPassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.Attribute.Definition</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.PathToDigitalSignaturesAndEncryptionApplicationsOnLinuxServers.Resource.Comment</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.EventHandlersReadFromFileOfExchangeRules</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.TabularSection.ContactInformation.Attribute.Region</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteRightsByAccessValues.Dimension.Right</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteObjectVersioningSettings.Resource.Use</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes.Attribute.FillOrder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DataExchangeRules.Attribute.RulesImported</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Currencies.Attribute.DescriptionFull</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.TabularSection.Commands.Attribute.Presentation</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ExchangeMessagesTransportFTP.Attribute.FTPConnectionPassiveConnection</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.ReceiverTypeAsString</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.Attribute.SourceTypeAsString</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.UserName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformation.Dimension.Object</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.TabularSection.ContactInformation.Attribute.Type</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AttachedFilesExist.Dimension.ObjectWithFiles</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.TabularSection.Content.Attribute.ExternalUser</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Currencies.Attribute.MainCurrency</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.UsersGroups.TabularSection.Content.Attribute.User</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ContactInformationKinds.Attribute.CanChangeEditMode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.UniqueReceiverHandle</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ReportBuilder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.WorldCountries.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.WorldCountries.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.WorldCountries.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.WorldCountries.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.WorldCountries.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.WorldCountries.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.WorldCountries.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.WorldCountries.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.SuccessfulDataExchangeStatus.Dimension.InfobaseNode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.SourceField4</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes.Attribute.FullPathWindows</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.PictureIndex</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.Attribute.AllAuthorizationObjects</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ObjectsVersions.Resource.ObjectVersioning</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.DeleteAccessKinds.StandardAttribute.ValueType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.DeleteAccessKinds.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.DeleteAccessKinds.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.DeleteAccessKinds.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.DeleteAccessKinds.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.DeleteAccessKinds.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.DeleteAccessKinds.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.DeleteAccessKinds.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.TabularSection.AccessValues.Attribute.AccessValue</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ExchangeFileName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.FTPConnectionPath</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AdditionalInformationProcessorsFunctions.Resource.UseReports</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.Version3Digit</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsers.Attribute.SetRolesDirectly</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.SuccessfulDataExchangeStatus.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.SuccessfulDataExchangeStatus.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.SuccessfulDataExchangeStatus.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.SuccessfulDataExchangeStatus.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.TabularSection.ContactInformation</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ChangeProhibitionDates.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ChangeProhibitionDates.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ChangeProhibitionDates.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ChangeProhibitionDates.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CalendarSchedules.Dimension.ScheduleDate</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsers.Attribute.AuthorizationObject</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.FTPConnectionPassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.TabularSection.ContactInformation</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.TabularSection.ContactInformation.Attribute.City</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ChangeProhibitionDates.Dimension.User</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.CommentDuringDataImport</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.NeedUpdateFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.OptimizedObjectWriting</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileStorageVolumes.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.WorldCountries.Attribute.AlphaCode3</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ConversionRulesTable</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.Check</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.EmailAddress</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.Attribute.StandardProfileChanged</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteRightsByAccessValues.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteRightsByAccessValues.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteRightsByAccessValues.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteRightsByAccessValues.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.FTPConnectionUser</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.TabularSection.Commands.Attribute.StartVariant</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.FTPConnectionPassiveConnection</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.FilesInWorkingDirectory.Resource.Size</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DistributedInfobaseObjectsConversion.Attribute.ItemCountInTransaction</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Currencies.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Currencies.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Currencies.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Currencies.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Currencies.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Currencies.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Currencies.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Currencies.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesObjectsCompliance.Dimension.SourceType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ExchangeFileCompressionPassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ChangeProhibitionDates.Dimension.Section</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.InfobaseNode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.Attribute.TableSourceObjectTypeName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DistributedInfobaseObjectsConversion.Attribute.EventLogMonitorMessageKey</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ExchangeMessagesTransportFTP.Attribute.FTPConnectionPort</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.UseTransportParametersFTP</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.InfobasesNodesCommonSettings.Resource.ExecuteInformationComparingCorrection</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.Attribute.TableFieldList</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.Parameters</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UserWorkBlocking.Attribute.ProhibitUserWorkTemporarily</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.CheckUpdateExistsOnStart</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Companies.TabularSection.ContactInformation.Attribute.ServerDomainName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UserPrintTemplates.Dimension.TemplateName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CurrencyRates.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CurrencyRates.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CurrencyRates.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CurrencyRates.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.SourceInfobasePrefixFilled</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.SourceField3</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Files</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#ByValuesAndSetsAdvanced("Catalog.Files", "", "",
"",
"",
"Object","T.FileOwner","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#ByValuesAndSetsAdvanced("Catalog.Files", "", "",
"",
"",
"Object","T.FileOwner","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")
</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#ByValuesAndSetsAdvanced("Catalog.Files", "", "",
"",
"",
"Object","T.FileOwner","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")
</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.Attribute.DataSuccessfullyImported</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.TabularSection.StatisticsInformation.Attribute.ThisIsObjectDeletion</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.TemporaryFileNameOfEventHandlers</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.FileVersions</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#ByValuesAndSetsAdvanced("Catalog.FileVersions", "", "",
"",
"",
"Object","T.Owner.FileOwner","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")
</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#ByValuesAndSetsAdvanced("Catalog.FileVersions", "", "",
"",
"",
"Object","T.Owner.FileOwner","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.DataExchangeCreationAssistant.Attribute.ThisInfobaseDescription</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.Attribute.Information</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.User</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AttachedFiles.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AttachedFiles.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AttachedFiles.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.AttachedFiles.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.SendReportToEMail</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.EmailExchangeMessagesTransport.Attribute.ExchangeMessageArchivePassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.TabularSection.AccessValues.Attribute.AccessKind</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.Attribute.Comment</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.OutgoingMailServer</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.SettingAutomaticDataImport</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.Attribute.DeleteObjectPresentation</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.WorkingFileDirectories.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.WorkingFileDirectories.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.WorkingFileDirectories.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.WorkingFileDirectories.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.Version</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ExchangeTransportSettings.Resource.FTPConnectionPath</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ExecuteDataExchangeInOptimizedFormat</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.TabularSection.Roles</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.Attribute.CreateBackup</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ExternalUsersGroups.TabularSection.Roles.Attribute.DeleteRole</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.TabularSection.Roles.Attribute.DeleteRole</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.TabularSection.ContactInformation.Attribute.ServerDomainName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.DataExchangeScripts.TabularSection.ExchangeSettings.Attribute.ExchangeTransportKind</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.PathToLocalFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseBackupSetup.Attribute.BackupImportingFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InteractiveDataExchangeAssistant.Attribute.ExchangeMessageFileName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.WorldCountries.Attribute.LongDescription</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.ReportsVariants.Attribute.Settings</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.PathToUpdateFile</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.DebugModeFlag</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CurrencyRates.Resource.Multiplicity</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.SortTable.Attribute.SortDirection</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CurrencyRates.Dimension.Currency</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.FilesInWorkingDirectory.Dimension.User</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups.Attribute.UsersType</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.Attribute.SearchFieldsOfReceiverTable</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.UsersGroupsContents.Dimension.UsersGroup</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupsProfiles.TabularSection.AccessKinds.Attribute.Preset</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.ScannedFileNumbers.Dimension.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.ExchangeProtocolFileName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.UniversalXMLDataExchange.Attribute.OutputInInformationMessagesToProtocol</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.Vendor</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.ConfigurationUpdate.TabularSection.AvailableUpdates.Attribute.Configuration</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.SortTable</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AdditionalReportsAndDataProcessors.Attribute.UseForListForm</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.Users.TabularSection.ContactInformation.Attribute.City</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.InfobaseObjectsMapping.TabularSection.TableOfAutomaticallyMappedObjects.Attribute.UniqueSourceHandle</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.POP3AuthenticationMode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.DeleteRightsByAccessValues.Resource.Prohibited</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.CalendarSchedules.Dimension.Calendar</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<restrictionTemplate>
		<name>ByValues</name>
		<condition>// ByValues(Table, -, Modifier, B1,P1, B2,P2, ..., IN(n), P(n)).
// No. parameter: 1, 2, 3, 4, 5, 6, 7, ..., 2+n*2,3+n*2.
// Read so: "access restriction by values".
// Parameters:
// Table - Name of the current table, for example, "Document.GoodsAndServicesReceipt".
// Modifier - changes template.
// 1-st modifier - the NotRestrictAccessToGroups
// row directs to unconditionally select groups of the hierarchical log. 
// Other modifiers in this version of the template are  expected.
// K(n) - Access kind - access kind name, for example, Companies. It's a good idea to specify
// several names for fields of a composite
// type for productivity increase, for example, Companies,PrivateIndividualsGroups, by specifying several parameters blocks with the same field name.
// You can use special kinds of
// access Condition, RightsSettings,ReadRight, ChangeRight only separately.
// When K(n) = Condition ( ""), then P(n) contains a condition row on
// language of query,
// for example, T.Author = &amp;AuthorizedUser, VALUETYPE (T.Owner) = TYPE (Catalog.Organization), where T - current table alias.
// When K(n) = ReadRight
//  ChangeRight checking if you have rights for value table T.P(n) is performed.
// F(n) - Field of verified value, except of K(n) case = Condition ( "").
// Note: you can increase the maximum quantity of simultaneously checked fields
// values by changing the template; but you should also specify all parameters of the pattern, namely specify empty rows, when the quantity of fields is less than maximum.
// The pattern has the following structure:
// &lt;Conditions common part&gt; &lt;Condition by parameters group 1&gt;  &lt;Condition by parameters group 2&gt;  ... &lt;Condition by
// parameters group(n)&gt; Example:
// ByValues("Document.GoodsAndServicesReceipt", "", "",
// "Companies","Company",
// "Vendors","Counterparty", "","", ...)

// Verification of the Right parameter.
#If  ("#Parameter(2)" = "Read"  "#Parameter(2)" = "Insert" 
 "#Parameter(2)" = "Update"  "#Parameter(2)" = "Delete"  "#Parameter(2)" = "")
  #CurrentAccessRightName &lt;&gt; "Read"  "#Parameter(2)" = "Read"
  #CurrentAccessRightName = "Read"  "#Parameter(2)" &lt;&gt; "Read"  "#Parameter(2)" &lt;&gt; "" #Then
 // When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
 InvalidRight: #Parameter(2)
#EndIf

// Verification of the TableName parameter.
#If "#Parameter(1)" &lt;&gt; #CurrentTableName #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Verification of the Modifier parameter.
#If  ("#Parameter(3)" = "DontLimitAccessToGroups"  "#Parameter(3)" = "") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	InvalidModifier: #Parameter(3)
#EndIf

// General checking of access restriction on record level
//  checking of usage at least of one restriction from listed access kinds.
#If &amp;LimitAccessOnRecordsLevel
   (
  ("#Parameter(4)" = ""  "#Parameter(5)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(4),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(4),"))
  ("#Parameter(6)" = ""  "#Parameter(7)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(6),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(6),"))
  ("#Parameter(8)" = ""  "#Parameter(9)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(8),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(8),"))
  ("#Parameter(10)" = ""  "#Parameter(11)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(10),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(10),"))
  ("#Parameter(12)" = ""  "#Parameter(13)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(12),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(12),"))
  ("#Parameter(14)" = ""  "#Parameter(15)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(14),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(14),"))
  ("#Parameter(16)" = ""  "#Parameter(17)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(16),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(16),"))
  ("#Parameter(18)" = ""  "#Parameter(19)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(18),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(18),"))
  ("#Parameter(20)" = ""  "#Parameter(21)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(20),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(20),"))
  ("#Parameter(22)" = ""  "#Parameter(23)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(22),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(22),"))
  ("#Parameter(24)" = ""  "#Parameter(25)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(24),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(24),"))
  ("#Parameter(26)" = ""  "#Parameter(27)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(26),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(26),"))
  ("#Parameter(28)" = ""  "#Parameter(29)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(28),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(28),"))
  ("#Parameter(30)" = ""  "#Parameter(31)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(30),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(30),"))
  ("#Parameter(32)" = ""  "#Parameter(33)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(32),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(32),"))
  ("#Parameter(34)" = ""  "#Parameter(35)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(34),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(34),"))
 ) #Then

T WHERE // T - alias of the current table (selected short to reduce the quantity of characters in the parameter text - conditions on language of requests).

// Unconditionally select groups in the hierarchical metadata object (if needed).
#If "#Parameter(3)" = "DontLimitAccessToGroups" #Then
	T.IsFolder 
#EndIf

 In
(	// Overall verification of user's right for current table.
	// Table rights are formed according to the content of acces group profile roles.
	SELECT TOP 1 
	FROM
		Catalog.MetadataObjectIDs AS PropertiesCurrentTable
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			 PropertiesCurrentTable.FullName = "#Parameter(1)"
			  In
			 (
				SELECT TOP 1 
				FROM
					InformationRegister.AccessGroupsTables AS AccessGroupsTables
					WHERE
						 AccessGroupsTables.Table = PropertiesCurrentTable.Ref
						 AccessGroupsTables.AccessGroup = AccessGroups.Ref
					#If  #CurrentAccessRightName = "Read" #Then
						 AccessGroupsTables.Update
					#EndIf
			 )
			 AccessGroups.Ref In
			 (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
					ON
						 UsersGroupsContents.User = &amp;AuthorizedUser
						 UsersGroupsContents.UsersGroup = AccessGroupsUsers.User
			 )
	WHERE
 ( // Search values of specified fields in the allowed access groups values (of users).

//// Value verification of parameters group field 1.
#If "#Parameter(4)" = "Condition"  "#Parameter(4)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	( #Parameter(5) )
#ElseIf "#Parameter(4)" = "ReadRight"  "#Parameter(4)" = "EditRight" #Then
	 T.#Parameter(5) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(5))
		#If  "#Parameter(4)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(4)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(5)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(5)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(4),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(4)", ",") #Then
		InvalidAccessKind: "#Parameter(4)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(4)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(4),") #Then
	
	 (
			ISNULL(T.#Parameter(5), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(4),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(4),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(5)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(4),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(5)
		#ElseIf "T.#Parameter(5)" = "T.Ref" #Then
			#If StrContains("#Parameter(4)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(4)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(4),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(5)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(5)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(5))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#Else
	
#EndIf

//// Value verification of parameters group field 2.
#If "#Parameter(6)" = ""  "#Parameter(7)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(6)" = "Condition"  "#Parameter(6)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(7) )
#ElseIf "#Parameter(6)" = "ReadRight"  "#Parameter(6)" = "EditRight" #Then
	 T.#Parameter(7) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(7))
		#If  "#Parameter(6)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(6)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(7)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(7)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(6),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(6)", ",") #Then
		InvalidAccessKind: "#Parameter(6)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(6)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(6),") #Then
	
	 (
			ISNULL(T.#Parameter(7), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(6),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(6),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(7)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(7)
		#ElseIf "T.#Parameter(7)" = "T.Ref" #Then
			#If StrContains("#Parameter(6)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(6)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(7)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(7)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(7))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 3.
#If "#Parameter(8)" = ""  "#Parameter(9)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(8)" = "Condition"  "#Parameter(8)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(9) )
#ElseIf "#Parameter(8)" = "ReadRight"  "#Parameter(8)" = "EditRight" #Then
	 T.#Parameter(9) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(9))
		#If  "#Parameter(8)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(8)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(9)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(9)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(8),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(8)", ",") #Then
		InvalidAccessKind: "#Parameter(8)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(8)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(8),") #Then
	
	 (
			ISNULL(T.#Parameter(9), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(8),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(8),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(9)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(8),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(9)
		#ElseIf "T.#Parameter(9)" = "T.Ref" #Then
			#If StrContains("#Parameter(8)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(8)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(8),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(9)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(9)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(9))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 4.
#If "#Parameter(10)" = ""  "#Parameter(11)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(10)" = "Condition"  "#Parameter(10)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(11) )
#ElseIf "#Parameter(10)" = "ReadRight"  "#Parameter(10)" = "EditRight" #Then
	 T.#Parameter(11) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(11))
		#If  "#Parameter(10)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(10)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(11)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(11)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(10),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(10)", ",") #Then
		InvalidAccessKind: "#Parameter(10)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(10)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(10),") #Then
	
	 (
			ISNULL(T.#Parameter(11), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(10),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(10),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(11)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(10),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(11)
		#ElseIf "T.#Parameter(11)" = "T.Ref" #Then
			#If StrContains("#Parameter(10)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(10)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(10),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(11)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(11)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(11))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 5.
#If "#Parameter(12)" = ""  "#Parameter(13)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(12)" = "Condition"  "#Parameter(12)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(13) )
#ElseIf "#Parameter(12)" = "ReadRight"  "#Parameter(12)" = "EditRight" #Then
	 T.#Parameter(13) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(13))
		#If  "#Parameter(12)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(12)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(13)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(13)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(12),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(12)", ",") #Then
		InvalidAccessKind: "#Parameter(12)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(12)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(12),") #Then
	
	 (
			ISNULL(T.#Parameter(13), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(12),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(12),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(13)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(13)
		#ElseIf "T.#Parameter(13)" = "T.Ref" #Then
			#If StrContains("#Parameter(12)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(12)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(13)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(13)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(13))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 6.
#If "#Parameter(14)" = ""  "#Parameter(15)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(14)" = "Condition"  "#Parameter(14)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(15) )
#ElseIf "#Parameter(14)" = "ReadRight"  "#Parameter(14)" = "EditRight" #Then
	 T.#Parameter(15) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(15))
		#If  "#Parameter(14)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(14)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(15)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(15)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(14),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(14)", ",") #Then
		InvalidAccessKind: "#Parameter(14)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(14)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(14),") #Then
	
	 (
			ISNULL(T.#Parameter(15), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(14),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(14),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(15)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(14),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(15)
		#ElseIf "T.#Parameter(15)" = "T.Ref" #Then
			#If StrContains("#Parameter(14)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(14)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(14),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(15)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(15)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(15))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 7.
#If "#Parameter(16)" = ""  "#Parameter(17)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(16)" = "Condition"  "#Parameter(16)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(17) )
#ElseIf "#Parameter(16)" = "ReadRight"  "#Parameter(16)" = "EditRight" #Then
	 T.#Parameter(17) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(17))
		#If  "#Parameter(16)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(16)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(17)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(17)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(16),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(16)", ",") #Then
		InvalidAccessKind: "#Parameter(16)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(16)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(16),") #Then
	
	 (
			ISNULL(T.#Parameter(17), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(16),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(16),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(17)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(16),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(17)
		#ElseIf "T.#Parameter(17)" = "T.Ref" #Then
			#If StrContains("#Parameter(16)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(16)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(16),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(17)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(17)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(17))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 8.
#If "#Parameter(18)" = ""  "#Parameter(19)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(18)" = "Condition"  "#Parameter(18)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(19) )
#ElseIf "#Parameter(18)" = "ReadRight"  "#Parameter(18)" = "EditRight" #Then
	 T.#Parameter(19) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(19))
		#If  "#Parameter(18)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(18)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(19)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(19)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(18),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(18)", ",") #Then
		InvalidAccessKind: "#Parameter(18)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(18)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(18),") #Then
	
	 (
			ISNULL(T.#Parameter(19), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(18),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(18),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(19)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(19)
		#ElseIf "T.#Parameter(19)" = "T.Ref" #Then
			#If StrContains("#Parameter(18)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(18)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(19)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(19)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(19))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 9.
#If "#Parameter(20)" = ""  "#Parameter(21)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(20)" = "Condition"  "#Parameter(20)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(21) )
#ElseIf "#Parameter(20)" = "ReadRight"  "#Parameter(20)" = "EditRight" #Then
	 T.#Parameter(21) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(21))
		#If  "#Parameter(20)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(20)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(21)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(21)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(20),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(20)", ",") #Then
		InvalidAccessKind: "#Parameter(20)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(20)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(20),") #Then
	
	 (
			ISNULL(T.#Parameter(21), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(20),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(20),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(21)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(20),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(21)
		#ElseIf "T.#Parameter(21)" = "T.Ref" #Then
			#If StrContains("#Parameter(20)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(20)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(20),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(21)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(21)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(21))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 10.
#If "#Parameter(22)" = ""  "#Parameter(23)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(22)" = "Condition"  "#Parameter(22)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(23) )
#ElseIf "#Parameter(22)" = "ReadRight"  "#Parameter(22)" = "EditRight" #Then
	 T.#Parameter(23) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(23))
		#If  "#Parameter(22)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(22)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(23)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(23)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(22),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(22)", ",") #Then
		InvalidAccessKind: "#Parameter(22)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(22)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(22),") #Then
	
	 (
			ISNULL(T.#Parameter(23), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(22),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(22),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(23)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(22),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(23)
		#ElseIf "T.#Parameter(23)" = "T.Ref" #Then
			#If StrContains("#Parameter(22)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(22)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(22),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(23)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(23)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(23))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 11.
#If "#Parameter(24)" = ""  "#Parameter(25)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(24)" = "Condition"  "#Parameter(24)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(25) )
#ElseIf "#Parameter(24)" = "ReadRight"  "#Parameter(24)" = "EditRight" #Then
	 T.#Parameter(25) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(25))
		#If  "#Parameter(24)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(24)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(25)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(25)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(24),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(24)", ",") #Then
		InvalidAccessKind: "#Parameter(24)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(24)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(24),") #Then
	
	 (
			ISNULL(T.#Parameter(25), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(24),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(24),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(25)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(25)
		#ElseIf "T.#Parameter(25)" = "T.Ref" #Then
			#If StrContains("#Parameter(24)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(24)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(25)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(25)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(25))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 12.
#If "#Parameter(26)" = ""  "#Parameter(27)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(26)" = "Condition"  "#Parameter(26)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(27) )
#ElseIf "#Parameter(26)" = "ReadRight"  "#Parameter(26)" = "EditRight" #Then
	 T.#Parameter(27) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(27))
		#If  "#Parameter(26)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(26)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(27)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(27)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(26),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(26)", ",") #Then
		InvalidAccessKind: "#Parameter(26)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(26)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(26),") #Then
	
	 (
			ISNULL(T.#Parameter(27), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(26),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(26),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(27)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(26),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(27)
		#ElseIf "T.#Parameter(27)" = "T.Ref" #Then
			#If StrContains("#Parameter(26)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(26)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(26),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(27)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(27)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(27))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 13.
#If "#Parameter(28)" = ""  "#Parameter(29)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(28)" = "Condition"  "#Parameter(28)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(29) )
#ElseIf "#Parameter(28)" = "ReadRight"  "#Parameter(28)" = "EditRight" #Then
	 T.#Parameter(29) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(29))
		#If  "#Parameter(28)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(28)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(29)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(29)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(28),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(28)", ",") #Then
		InvalidAccessKind: "#Parameter(28)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(28)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(28),") #Then
	
	 (
			ISNULL(T.#Parameter(29), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(28),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(28),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(29)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(28),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(29)
		#ElseIf "T.#Parameter(29)" = "T.Ref" #Then
			#If StrContains("#Parameter(28)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(28)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(28),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(29)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(29)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(29))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 14.
#If "#Parameter(30)" = ""  "#Parameter(31)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(30)" = "Condition"  "#Parameter(30)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(31) )
#ElseIf "#Parameter(30)" = "ReadRight"  "#Parameter(30)" = "EditRight" #Then
	 T.#Parameter(31) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(31))
		#If  "#Parameter(30)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(30)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(31)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(31)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(30),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(30)", ",") #Then
		InvalidAccessKind: "#Parameter(30)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(30)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(30),") #Then
	
	 (
			ISNULL(T.#Parameter(31), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(30),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(30),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(31)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(31)
		#ElseIf "T.#Parameter(31)" = "T.Ref" #Then
			#If StrContains("#Parameter(30)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(30)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(31)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(31)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(31))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 15.
#If "#Parameter(32)" = ""  "#Parameter(33)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(32)" = "Condition"  "#Parameter(32)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(33) )
#ElseIf "#Parameter(32)" = "ReadRight"  "#Parameter(32)" = "EditRight" #Then
	 T.#Parameter(33) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(33))
		#If  "#Parameter(32)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(32)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(33)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(33)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(32),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(32)", ",") #Then
		InvalidAccessKind: "#Parameter(32)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(32)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(32),") #Then
	
	 (
			ISNULL(T.#Parameter(33), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(32),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(32),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(33)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(32),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(33)
		#ElseIf "T.#Parameter(33)" = "T.Ref" #Then
			#If StrContains("#Parameter(32)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(32)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(32),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(33)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(33)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(33))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

//// Value verification of parameters group field 16.
#If "#Parameter(34)" = ""  "#Parameter(35)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(34)" = "Condition"  "#Parameter(34)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(35) )
#ElseIf "#Parameter(34)" = "ReadRight"  "#Parameter(34)" = "EditRight" #Then
	 T.#Parameter(35) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(35))
		#If  "#Parameter(34)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(34)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(35)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(35)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(34),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(34)", ",") #Then
		InvalidAccessKind: "#Parameter(34)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(34)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(34),") #Then
	
	 (
			ISNULL(T.#Parameter(35), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(34),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(34),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = T.#Parameter(35)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(34),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.#Parameter(35)
		#ElseIf "T.#Parameter(35)" = "T.Ref" #Then
			#If StrContains("#Parameter(34)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(34)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(34),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = T.#Parameter(35)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = T.#Parameter(35)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(35))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )
#EndIf

 )
)
#EndIf

</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ByValuesAndSetsAdvanced</name>
		<condition>// ByValuesAndSetsAdvanced(Table, -, Modifier, JoinedTables, O, B1,P1,O1, B2,P2,O2,..., IN(n), P(n), O(n)).
// No. parameter: 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,...,3+n*3,4+n*3,5+n*3.
// Reads as: "restriction of access to values  sets of advanced".
// Parameters:
// Table - Name of the current table, for example, "Document.GoodsAndServicesReceipt".
// Modifier - changes template.
// 1-st modifier - the NotRestrictAccessToGroups
// row directs to unconditionally select groups of the hierarchical log.
// 2-nd modifier - the string "ExtendedOR" indicates
// for restrictions, for example, "ByCompanies 
// ByAccounts", to make extended validation for which the option settings
// kind of access in the "All allowed, no prohibited" access groups is considered to be as "Access kind is  used".
// If this modifier is  available, then the result
// is , which leads to the final result ;
// if "All allowed, no prohibited" at least one of the access kinds (either ByCompanies either ByAccounts).
// Modifier has meaning only when the verifying sets values of access.
// You can use combinations
// of modifiers: "DontLimitAccessToGroups" "ExtendedOR" "DontLimitAccessToGroups, ExtendedOR".
// Other modifiers in this version of the template are  expected.
// JoinedTables - the text of joining additional tables in
// the query language such as
// "INNER JOIN Document.ExpenseReport.PaymentToVendor AS T1 On T.Ref = T1.Ref".
// Joining allows to specify the fields of PaymentToVendor table,
// as the fields of the main table for verifying their values, as the main table values.
// You should remember that in case of multiplication of the
// lines in the result of connection, it is enough that the only one line pass the verification conditions, in other words the lines verification results unite on "".
// O - Initial brackets "(".
// K(n) - Access kind - access kind name, for example, Companies. It's a good idea to specify
// several names for fields of a composite
// type for productivity increase, for example, Companies,PrivateIndividualsGroups, by specifying several parameters blocks with the same field name.
// Special kinds of access object "Condition"
// "RightsSettings" "ReadingRights" "ChangingRights" can use only separately.
// When K(n) = Condition ( ""), then P(n) contains a condition row on
// language of query,
// for example, T.Author = &amp;AuthorizedUser, VALUETYPE (T.Owner) = TYPE (Catalog.Organization), where T - current table alias.
// When K(n) = "ReadRight"
//  "ChangeRight" checking if you have rights for value table T.F(n) is run.
// When K n = "object"  ""
// When there are Dependencies rights record in the register information
// AccessRightsCorrelation Then executing Checking Rights reading etc n  sets the
// values of access to register information Access NaboryValuesOf readable on link etc n for Rights reading;
// otherwise use the default rule:
// When Right = "reading", then checking reading rights is run T.F(n) 
// the access value sets in the AccessValuesSets information register, which are read on ref T.F(n) for reading rights;
// When Right = "Changing", then checking changing rights is
// run T.F(n)  the access value sets access in information register AccessValuesSets, which are read on link T.F(n) for changing rights
// F(n) - Field of verified value with an
// alias such as "T.Organization except the case of K(n) = "Condition" ( "").
// O(n) - Logical operations "", "" in combination with brackets "(", ")".
// Note: you can increase the maximum quantity of simultaneously checked fields
// values by changing the template; but you should also specify all parameters of the pattern, namely specify empty rows, when the quantity of fields is less than maximum.
// The pattern has the following structure:
// &lt;Join on table1&gt; &lt;Join on table2&gt; ... &lt;Join
// by table(m)&gt; &lt;Common conditions part&gt; &lt;Condition on parameters group 1&gt; / &lt;Condition on parameters group 1&gt; / ... &lt;Condition by
// parameters group(n)&gt; Example:
// ByValuesAndSetsAdvanced("DocumentJournal.WarehouseDocuments", "", "",
// "",
// "",
// "Object","T.Ref","",
// "Object","T.MainDocument","", "","","", ...)

// Verification of the Right parameter.
#If  ("#Parameter(2)" = "Read"  "#Parameter(2)" = "Insert" 
 "#Parameter(2)" = "Update"  "#Parameter(2)" = "Delete"  "#Parameter(2)" = "")
  #CurrentAccessRightName &lt;&gt; "Read"  "#Parameter(2)" = "Read"
  #CurrentAccessRightName = "Read"  "#Parameter(2)" &lt;&gt; "Read"  "#Parameter(2)" &lt;&gt; "" #Then
 // When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
 InvalidRight: #Parameter(2)
#EndIf

// Verification of the TableName parameter.
#If "#Parameter(1)" &lt;&gt; #CurrentTableName #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Verification of the Modifier parameter.
#If  ( "#Parameter(3)" = "DontLimitAccessToGroups"
  "#Parameter(3)" = "ExtendedOR"
  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR"
  "#Parameter(3)" = "") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	InvalidModifier: #Parameter(3)
#EndIf

// General checking of access restriction on record level
//  checking of usage at least of one restriction from listed access kinds.
#If &amp;LimitAccessOnRecordsLevel
   (
  ("#Parameter(6)" = ""  "#Parameter(7)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(6),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(6),"))
  ("#Parameter(9)" = ""  "#Parameter(10)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(9),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(9),"))
  ("#Parameter(12)" = ""  "#Parameter(13)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(12),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(12),"))
  ("#Parameter(15)" = ""  "#Parameter(16)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(15),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(15),"))
  ("#Parameter(18)" = ""  "#Parameter(19)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(18),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(18),"))
  ("#Parameter(21)" = ""  "#Parameter(22)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(21),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(21),"))
  ("#Parameter(24)" = ""  "#Parameter(25)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(24),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(24),"))
  ("#Parameter(27)" = ""  "#Parameter(28)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(27),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(27),"))
  ("#Parameter(30)" = ""  "#Parameter(31)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(30),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(30),"))
  ("#Parameter(33)" = ""  "#Parameter(34)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(33),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(33),"))
  ("#Parameter(36)" = ""  "#Parameter(37)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(36),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(36),"))
  ("#Parameter(39)" = ""  "#Parameter(40)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(39),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(39),"))
  ("#Parameter(42)" = ""  "#Parameter(43)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(42),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(42),"))
  ("#Parameter(45)" = ""  "#Parameter(46)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(45),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(45),"))
  ("#Parameter(48)" = ""  "#Parameter(49)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(48),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(48),"))
  ("#Parameter(51)" = ""  "#Parameter(52)" = ""
  &amp;AccessKindsWithDisabledUse = "All"
   StrContains(",Condition,,RightsSettings,Object, ,ReadRight,ChangeRight,", ",#Parameter(51),")
  StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(51),"))
 ) #Then

T FROM T // T - alias of the current table (selected short to reduce the quantity of characters in the parameter text - conditions on language of requests).

// Attachable tables to the verifing line of the current table "T".
#Parameter(4)

WHERE

// Unconditionally select groups in the hierarchical metadata object (if needed).
#If "#Parameter(3)" = "DontLimitAccessToGroups"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
	T.IsFolder 
#EndIf

 In
(	// Overall verification of user's right for current table.
	// Table rights are formed according to the content of acces group profile roles.
	SELECT TOP 1 
	FROM
		Catalog.MetadataObjectIDs AS PropertiesCurrentTable
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			 PropertiesCurrentTable.FullName = "#Parameter(1)"
			  In
			 (
				SELECT TOP 1 
				FROM
					InformationRegister.AccessGroupsTables AS AccessGroupsTables
					WHERE
						 AccessGroupsTables.Table = PropertiesCurrentTable.Ref
						 AccessGroupsTables.AccessGroup = AccessGroups.Ref
					#If  #CurrentAccessRightName = "Read" #Then
						 AccessGroupsTables.Update
					#EndIf
			 )
			 AccessGroups.Ref In
			 (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
					ON
						 UsersGroupsContents.User = &amp;AuthorizedUser
						 UsersGroupsContents.UsersGroup = AccessGroupsUsers.User
			 )
	WHERE
 ( // Search values of specified fields in the allowed access groups values (of users).

	#Parameter(5) // [([(][(]...] 0-n opening brackets.

//// Value verification of parameters group field 1.
#If "#Parameter(6)" = "Condition"  "#Parameter(6)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	( #Parameter(7) )
#ElseIf "#Parameter(6)" = "ReadRight"  "#Parameter(6)" = "EditRight" #Then
	 #Parameter(7) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(7))
		#If  "#Parameter(6)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(6)" = "Object"  "#Parameter(6)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(7))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(7))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(7))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(7)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(7)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(7)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(7))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(7)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(7)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(7))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(7)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(7)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(6)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(7)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(7)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(6),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(6)", ",") #Then
		InvalidAccessKind: "#Parameter(6)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(6)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(6),") #Then
	
	 (
			ISNULL(#Parameter(7), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(6),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(6),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(7)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(7)
		#ElseIf "#Parameter(7)" = "T.Ref" #Then
			#If StrContains("#Parameter(6)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(6)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(7)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(7)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(7))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(8) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 2.
#If "#Parameter(9)" = ""  "#Parameter(10)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(9)" = "Condition"  "#Parameter(9)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(10) )
#ElseIf "#Parameter(9)" = "ReadRight"  "#Parameter(9)" = "EditRight" #Then
	 #Parameter(10) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(10))
		#If  "#Parameter(9)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(9)" = "Object"  "#Parameter(9)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(10))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(10))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(10))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(10)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(10)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(10)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(10))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(10)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(10)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(10))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(10)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(10)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(9)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(10)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(10)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(9),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(9)", ",") #Then
		InvalidAccessKind: "#Parameter(9)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(9)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(9),") #Then
	
	 (
			ISNULL(#Parameter(10), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(9),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(9),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(10)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(9),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(10)
		#ElseIf "#Parameter(10)" = "T.Ref" #Then
			#If StrContains("#Parameter(9)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(9)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(9),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(10)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(10)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(10))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(11) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 3.
#If "#Parameter(12)" = ""  "#Parameter(13)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(12)" = "Condition"  "#Parameter(12)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(13) )
#ElseIf "#Parameter(12)" = "ReadRight"  "#Parameter(12)" = "EditRight" #Then
	 #Parameter(13) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(13))
		#If  "#Parameter(12)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(12)" = "Object"  "#Parameter(12)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(13))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(13))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(13))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(13)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(13)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(13)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(13))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(13)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(13)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(13))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(13)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(13)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(12)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(13)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(13)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(12),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(12)", ",") #Then
		InvalidAccessKind: "#Parameter(12)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(12)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(12),") #Then
	
	 (
			ISNULL(#Parameter(13), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(12),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(12),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(13)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(13)
		#ElseIf "#Parameter(13)" = "T.Ref" #Then
			#If StrContains("#Parameter(12)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(12)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(13)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(13)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(13))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(14) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 4.
#If "#Parameter(15)" = ""  "#Parameter(16)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(15)" = "Condition"  "#Parameter(15)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(16) )
#ElseIf "#Parameter(15)" = "ReadRight"  "#Parameter(15)" = "EditRight" #Then
	 #Parameter(16) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(16))
		#If  "#Parameter(15)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(15)" = "Object"  "#Parameter(15)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(16))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(16))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(16))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(16)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(16)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(16)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(16))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(16)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(16)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(16))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(16)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(16)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(15)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(16)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(16)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(15),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(15)", ",") #Then
		InvalidAccessKind: "#Parameter(15)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(15)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(15),") #Then
	
	 (
			ISNULL(#Parameter(16), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(15),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(15),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(16)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(15),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(16)
		#ElseIf "#Parameter(16)" = "T.Ref" #Then
			#If StrContains("#Parameter(15)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(15)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(15),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(16)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(16)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(16))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(17) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 5.
#If "#Parameter(18)" = ""  "#Parameter(19)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(18)" = "Condition"  "#Parameter(18)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(19) )
#ElseIf "#Parameter(18)" = "ReadRight"  "#Parameter(18)" = "EditRight" #Then
	 #Parameter(19) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(19))
		#If  "#Parameter(18)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(18)" = "Object"  "#Parameter(18)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(19))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(19))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(19))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(19)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(19)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(19)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(19))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(19)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(19)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(19))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(19)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(19)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(18)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(19)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(19)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(18),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(18)", ",") #Then
		InvalidAccessKind: "#Parameter(18)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(18)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(18),") #Then
	
	 (
			ISNULL(#Parameter(19), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(18),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(18),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(19)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(19)
		#ElseIf "#Parameter(19)" = "T.Ref" #Then
			#If StrContains("#Parameter(18)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(18)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(19)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(19)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(19))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(20) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 6.
#If "#Parameter(21)" = ""  "#Parameter(22)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(21)" = "Condition"  "#Parameter(21)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(22) )
#ElseIf "#Parameter(21)" = "ReadRight"  "#Parameter(21)" = "EditRight" #Then
	 #Parameter(22) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(22))
		#If  "#Parameter(21)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(21)" = "Object"  "#Parameter(21)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(22))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(22))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(22))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(22)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(22)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(22)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(22))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(22)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(22)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(22))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(22)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(22)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(21)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(22)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(22)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(21),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(21)", ",") #Then
		InvalidAccessKind: "#Parameter(21)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(21)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(21),") #Then
	
	 (
			ISNULL(#Parameter(22), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(21),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(21),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(22)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(21),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(22)
		#ElseIf "#Parameter(22)" = "T.Ref" #Then
			#If StrContains("#Parameter(21)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(21)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(21),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(22)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(22)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(22))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(23) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 7.
#If "#Parameter(24)" = ""  "#Parameter(25)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(24)" = "Condition"  "#Parameter(24)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(25) )
#ElseIf "#Parameter(24)" = "ReadRight"  "#Parameter(24)" = "EditRight" #Then
	 #Parameter(25) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(25))
		#If  "#Parameter(24)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(24)" = "Object"  "#Parameter(24)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(25))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(25))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(25))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(25)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(25)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(25)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(25))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(25)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(25)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(25))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(25)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(25)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(24)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(25)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(25)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(24),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(24)", ",") #Then
		InvalidAccessKind: "#Parameter(24)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(24)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(24),") #Then
	
	 (
			ISNULL(#Parameter(25), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(24),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(24),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(25)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(25)
		#ElseIf "#Parameter(25)" = "T.Ref" #Then
			#If StrContains("#Parameter(24)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(24)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(25)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(25)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(25))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(26) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 8.
#If "#Parameter(27)" = ""  "#Parameter(28)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(27)" = "Condition"  "#Parameter(27)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(28) )
#ElseIf "#Parameter(27)" = "ReadRight"  "#Parameter(27)" = "EditRight" #Then
	 #Parameter(28) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(28))
		#If  "#Parameter(27)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(27)" = "Object"  "#Parameter(27)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(28))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(28))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(28))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(28)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(28)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(28)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(28))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(28)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(28)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(28))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(28)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(28)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(27)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(28)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(28)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(27),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(27)", ",") #Then
		InvalidAccessKind: "#Parameter(27)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(27)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(27),") #Then
	
	 (
			ISNULL(#Parameter(28), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(27),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(27),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(28)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(27),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(28)
		#ElseIf "#Parameter(28)" = "T.Ref" #Then
			#If StrContains("#Parameter(27)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(27)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(27),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(28)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(28)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(28))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(29) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 9.
#If "#Parameter(30)" = ""  "#Parameter(31)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(30)" = "Condition"  "#Parameter(30)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(31) )
#ElseIf "#Parameter(30)" = "ReadRight"  "#Parameter(30)" = "EditRight" #Then
	 #Parameter(31) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(31))
		#If  "#Parameter(30)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(30)" = "Object"  "#Parameter(30)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(31))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(31))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(31))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(31)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(31)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(31)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(31))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(31)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(31)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(31))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(31)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(31)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(30)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(31)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(31)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(30),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(30)", ",") #Then
		InvalidAccessKind: "#Parameter(30)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(30)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(30),") #Then
	
	 (
			ISNULL(#Parameter(31), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(30),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(30),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(31)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(31)
		#ElseIf "#Parameter(31)" = "T.Ref" #Then
			#If StrContains("#Parameter(30)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(30)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(31)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(31)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(31))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(32) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 10.
#If "#Parameter(33)" = ""  "#Parameter(34)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(33)" = "Condition"  "#Parameter(33)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(34) )
#ElseIf "#Parameter(33)" = "ReadRight"  "#Parameter(33)" = "EditRight" #Then
	 #Parameter(34) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(34))
		#If  "#Parameter(33)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(33)" = "Object"  "#Parameter(33)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(34))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(34))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(34))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(34)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(34)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(34)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(34))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(34)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(34)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(34))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(34)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(34)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(33)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(34)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(34)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(33),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(33)", ",") #Then
		InvalidAccessKind: "#Parameter(33)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(33)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(33),") #Then
	
	 (
			ISNULL(#Parameter(34), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(33),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(33),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(34)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(33),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(34)
		#ElseIf "#Parameter(34)" = "T.Ref" #Then
			#If StrContains("#Parameter(33)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(33)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(33),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(34)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(34)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(34))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(35) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 11.
#If "#Parameter(36)" = ""  "#Parameter(37)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(36)" = "Condition"  "#Parameter(36)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(37) )
#ElseIf "#Parameter(36)" = "ReadRight"  "#Parameter(36)" = "EditRight" #Then
	 #Parameter(37) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(37))
		#If  "#Parameter(36)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(36)" = "Object"  "#Parameter(36)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(37))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(37))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(37))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(37)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(37)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(37)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(37))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(37)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(37)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(37))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(37)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(37)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(36)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(37)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(37)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(36),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(36)", ",") #Then
		InvalidAccessKind: "#Parameter(36)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(36)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(36),") #Then
	
	 (
			ISNULL(#Parameter(37), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(36),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(36),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(37)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(36),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(37)
		#ElseIf "#Parameter(37)" = "T.Ref" #Then
			#If StrContains("#Parameter(36)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(36)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(36),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(37)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(37)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(37))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(38) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 12.
#If "#Parameter(39)" = ""  "#Parameter(40)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(39)" = "Condition"  "#Parameter(39)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(40) )
#ElseIf "#Parameter(39)" = "ReadRight"  "#Parameter(39)" = "EditRight" #Then
	 #Parameter(40) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(40))
		#If  "#Parameter(39)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(39)" = "Object"  "#Parameter(39)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(40))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(40))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(40))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(40)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(40)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(40)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(40))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(40)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(40)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(40))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(40)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(40)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(39)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(40)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(40)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(39),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(39)", ",") #Then
		InvalidAccessKind: "#Parameter(39)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(39)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(39),") #Then
	
	 (
			ISNULL(#Parameter(40), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(39),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(39),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(40)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(39),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(40)
		#ElseIf "#Parameter(40)" = "T.Ref" #Then
			#If StrContains("#Parameter(39)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(39)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(39),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(40)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(40)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(40))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(41) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 13.
#If "#Parameter(42)" = ""  "#Parameter(43)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(42)" = "Condition"  "#Parameter(42)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(43) )
#ElseIf "#Parameter(42)" = "ReadRight"  "#Parameter(42)" = "EditRight" #Then
	 #Parameter(43) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(43))
		#If  "#Parameter(42)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(42)" = "Object"  "#Parameter(42)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(43))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(43))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(43))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(43)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(43)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(43)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(43))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(43)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(43)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(43))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(43)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(43)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(42)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(43)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(43)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(42),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(42)", ",") #Then
		InvalidAccessKind: "#Parameter(42)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(42)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(42),") #Then
	
	 (
			ISNULL(#Parameter(43), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(42),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(42),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(43)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(42),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(43)
		#ElseIf "#Parameter(43)" = "T.Ref" #Then
			#If StrContains("#Parameter(42)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(42)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(42),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(43)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(43)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(43))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(44) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 14.
#If "#Parameter(45)" = ""  "#Parameter(46)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(45)" = "Condition"  "#Parameter(45)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(46) )
#ElseIf "#Parameter(45)" = "ReadRight"  "#Parameter(45)" = "EditRight" #Then
	 #Parameter(46) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(46))
		#If  "#Parameter(45)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(45)" = "Object"  "#Parameter(45)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(46))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(46))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(46))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(46)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(46)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(46)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(46))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(46)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(46)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(46))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(46)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(46)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(45)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(46)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(46)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(45),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(45)", ",") #Then
		InvalidAccessKind: "#Parameter(45)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(45)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(45),") #Then
	
	 (
			ISNULL(#Parameter(46), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(45),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(45),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(46)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(45),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(46)
		#ElseIf "#Parameter(46)" = "T.Ref" #Then
			#If StrContains("#Parameter(45)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(45)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(45),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(46)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(46)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(46))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(47) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 15.
#If "#Parameter(48)" = ""  "#Parameter(49)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(48)" = "Condition"  "#Parameter(48)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(49) )
#ElseIf "#Parameter(48)" = "ReadRight"  "#Parameter(48)" = "EditRight" #Then
	 #Parameter(49) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(49))
		#If  "#Parameter(48)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(48)" = "Object"  "#Parameter(48)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(49))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(49))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(49))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(49)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(49)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(49)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(49))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(49)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(49)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(49))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(49)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(49)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(48)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(49)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(49)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(48),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(48)", ",") #Then
		InvalidAccessKind: "#Parameter(48)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(48)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(48),") #Then
	
	 (
			ISNULL(#Parameter(49), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(48),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(48),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(49)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(48),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(49)
		#ElseIf "#Parameter(49)" = "T.Ref" #Then
			#If StrContains("#Parameter(48)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(48)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(48),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(49)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(49)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(49))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(50) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

//// Value verification of parameters group field 16.
#If "#Parameter(51)" = ""  "#Parameter(52)" = "" #Then
	// Parameters group is  used.
#ElseIf "#Parameter(51)" = "Condition"  "#Parameter(51)" = "" #Then
	// When the Condition access kind name ( ""), then instead of field name condition is specified.
	 ( #Parameter(52) )
#ElseIf "#Parameter(51)" = "ReadRight"  "#Parameter(51)" = "EditRight" #Then
	 #Parameter(52) &lt;&gt; 
	  In
	 (	// Verification of user's right for the Values table set in the field.
		SELECT TOP 1 
		FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			 VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(52))
		#If  "#Parameter(51)" = "ReadRight" #Then
			 AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(51)" = "Object"  "#Parameter(51)" = " " #Then
	(
		// Checking Rights object leading table Rightsm dependency)
		(
			 In
			(
			SELECT TOP 1 
			FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesOfObjectRightCheck
			WHERE
				 AccessGroupTablesOfObjectRightCheck.AccessGroup = AccessGroups.Ref
				 VALUETYPE(AccessGroupTablesOfObjectRightCheck.TableType) = VALUETYPE(#Parameter(52))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking leading right for
				// Reading Right Reading right can depend only on Reading right
			#Else
				// Checking leading right for
				// Changing Right Changing right can depend only on leading rights Reading, Changing
				 
				(	 AccessGroupTablesOfObjectRightCheck.Update = false
					   In
					(
					SELECT TOP 1 
					FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
					WHERE
						 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
						 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(52))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table's restriction of object right
		 
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		CASE WHEN  In
				(
					SELECT TOP 1 
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(52))
						 IDs.EmptyRefValue IN (&amp;RightSettingsOwnerTypes)
				)
		THEN
			(
				 IN // Verifying that right is allowed for user  a user group.
					(
					SELECT TOP 1 
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(52)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
				  false IN // Checking if the right is forfeited for user  any user group
					(
					SELECT TOP 1 false
					FROM InformationRegister.ObjectRightsSettings AS RightSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(52)
							 RightSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
						#Else
						 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
							 RightSettings.Table = PropertiesCurrentTable.Ref
						 #Else
							 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
						#EndIf
						INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
						ON
							 UsersGroupsContents.User = &amp;AuthorizedUser
							 UsersGroupsContents.UsersGroup = RightSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
		
		 (
		  IN //  all the checks are disabled.
		 (
				SELECT TOP 1  // Select the first set with enabled checking.
				FROM InformationRegister.AccessValuesSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(52)
				#If #CurrentAccessRightName = "Read" #Then
					// Reading right can depend only on reading right
					 SetNumbers.Read = 
				#Else
					// Changing right can depend on leading rights Reading, Changing
					 CASE
						WHEN  In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
							WHERE
								 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
								 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(52))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(52)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
		 )  
	#Else
		 (
	#EndIf
		  In
		 (
			SELECT TOP 1  // Select the first set for which access is allowed.
			FROM InformationRegister.AccessValuesSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(52)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				 SetNumbers.Read = 
			#Else
				// Changing right can depend on leading rights Reading, Changing
				 CASE
					WHEN  In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessRightsCorrelation AS AccessRightsCorrelation
						WHERE
							 AccessRightsCorrelation.SubordinateTable = PropertiesCurrentTable.Ref
							 VALUETYPE(AccessRightsCorrelation.MasterTableType) = VALUETYPE(#Parameter(52))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				
			 #If "#Parameter(3)" = "ExtendedOR"  "#Parameter(3)" = "DontLimitAccessToGroups,ExtendedOR" #Then
				 IN //  all the checks of the current set are disabled.
				(
					SELECT TOP 1  // Select the first enabled check of current set.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(52)
						 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
						   In
							(
								SELECT TOP 1  // Search access restrictions settings
								FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									 DefaultValues.WithoutSetup = 
							)
				)
				
			 #EndIf
				  false IN // All the checks are successful.
				(
				SELECT TOP 1 false // Select the first  permitted access value.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(52)
					 ValueSets.NumberOfSet = SetNumbers.NumberOfSet
					 
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If  &amp;AccessKindsWithDisabledUse = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					 In
						(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupsValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								 Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					 In
					(
						SELECT TOP 1 
						FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;AccessKindsWithDisabledUse = "All" #Then
				THEN
					
			#Else
				THEN
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If  #CurrentAccessRightName = "Read" #Then
					WHEN
						  In
							(
							SELECT TOP 1 
							FROM Catalog.MetadataObjectIDs AS TypesOfReferences
							WHERE
								 VALUETYPE(TypesOfReferences.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								 TypesOfReferences.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								 ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If  StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					WHEN
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								 AccessValuesGroups.AccessValue = ValueSets.AccessValue
								 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						
				#EndIf
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						 In
							(
							SELECT TOP 1 
							FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									 DefaultValues.AccessGroup = AccessGroups.Ref
									 VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupsValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									 Values.AccessValue = ValueGroups.AccessValuesGroup
							WHERE
								ISNULL(Values.ValueAllowed, DefaultValues.AllAllowed)
							)
				#If  #CurrentAccessRightName = "Read"
				   StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")
				   StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking prior false   single line values set.
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessPermitted)
				THEN 
				WHEN ValueSets.AccessValue = (Enum.AdditionalAccessValues.AccessDenied)
				THEN false
				// Checking if user has the access to AccessValue table.
				WHEN VALUETYPE(ValueSets.AccessValue) = Type(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Reading right can depend only on reading right
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN  In
					(	SELECT TOP 1 
						FROM InformationRegister.AccessGroupsTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							 AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							 (ValueSets.Adjustment &lt;&gt; (Catalog.MetadataObjectIDs.EmptyRef)
									 AccessGroupTablesObjectRightCheck.Update = false)
					)
			#EndIf
			#If  &amp;RightSettingsOwnerTypes = "" #Then
				ELSE
					(
					 IN // Verifying that right is allowed for user  a user group.
						(
						SELECT TOP 1 
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					  false IN // Checking if the right is forfeited for user  any user group
						(
						SELECT TOP 1 false
						FROM InformationRegister.ObjectRightsSettings AS RightSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								 RightSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
							#Else
								 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
								 RightSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;TablesIDsWithSeparateRightSettings)
									THEN ValueSets.Adjustment
									ELSE (Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
							ON
								 UsersGroupsContents.User = &amp;AuthorizedUser
								 UsersGroupsContents.UsersGroup = RightSettings.User
						)
					)
			#Else
				ELSE
					false
			#EndIf
				END
				) //  false IN
		 )
		 )
	#If  &amp;RightSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElseIf "#Parameter(51)" = "RightSettings" #Then
	
	 (
		 IN // Verifying that right is allowed for user  a user group.
			(
			SELECT TOP 1 
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(52)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangePermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
		   false IN // Verifying that right is  allowed for user  a user group.
			(
			SELECT TOP 1 false
			FROM InformationRegister.ObjectRightsSettings AS RightSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(52)
					 RightSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					 SettingsInheritance.UseLevel &lt; RightSettings.ReadingDeniedLevel
				#Else
				 #If StrContains(&amp;TablesWithSeparateRightSettings, "|#Parameter(1);") #Then
					 RightSettings.Table = PropertiesCurrentTable.Ref
				 #Else
					 RightSettings.Table = (Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					 SettingsInheritance.UseLevel &lt; RightSettings.ChangeDeniedLevel
				#EndIf
				INNER JOIN InformationRegister.UsersGroupsContents AS UsersGroupsContents
				ON
					 UsersGroupsContents.User = &amp;AuthorizedUser
					 UsersGroupsContents.UsersGroup = RightSettings.User
			)
	 )
#ElseIf  StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(51),") #Then
	// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
	#If StrContains("#Parameter(51)", ",") #Then
		InvalidAccessKind: "#Parameter(51)" - "The list of access type names is  found"
	#Else
		InvalidAccessKind: "#Parameter(51)" - "Access type name is  found"
	#EndIf
#ElseIf &amp;AccessKindsWithDisabledUse &lt;&gt; "All"
   StrContains(&amp;AccessKindsWithDisabledUse, ",#Parameter(51),") #Then
	
	 (
			ISNULL(#Parameter(52), ) &lt;&gt; 
			
		#If ( StrContains(&amp;AccessKindsWithDisabledUse, ",Users,")  StrContains(",#Parameter(51),", ",Users,"))
		  ( StrContains(&amp;AccessKindsWithDisabledUse, ",ExternalUsers,")  StrContains(",#Parameter(51),", ",ExternalUsers,")) #Then
			
			(
			  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					 AccessValuesGroups.AccessValue = #Parameter(52)
					 AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			 
		#Else
			(
		#EndIf
			CASE
			WHEN  In
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValue, ",#Parameter(51),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = #Parameter(52)
		#ElseIf "#Parameter(52)" = "T.Ref" #Then
			#If StrContains("#Parameter(51)", ",") #Then
				// When the parameter is set incorrectly, a row is inserted to create an error of access restriction build.
				InvalidAccessKind: "#Parameter(51)" - "When verifying the access value table, you can specify only one access kind"
			#ElseIf StrContains(&amp;AccessKindsWithOneGroupForAccessValue, ",#Parameter(51),") #Then
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify several access values groups.
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessGroup
					 ValueGroups.Ref = #Parameter(52)
			#EndIf
		#Else
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					 Values.AccessValue = ValueGroups.AccessValuesGroup
					 ValueGroups.AccessValue = #Parameter(52)
		#EndIf
				)
			THEN 
			ELSE false
			END
			=
			CASE
			WHEN  In
				(
				SELECT TOP 1 
				FROM InformationRegister.AccessGroupsDefaultValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				  VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(52))
				  DefaultValues.AllAllowed = false
				)
			THEN 
			ELSE false
			END
			)
	 )

#Else
	
#EndIf

	#Parameter(53) // [)[)][)]...] [|] [([(][(]...] operator / with/without brackets.

 )
)
#EndIf

</condition>
	</restrictionTemplate>
</Rights>
